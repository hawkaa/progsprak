#
# UTVIDELSER AV DEN DEKLARATIVE MODELLEN
#

# The declerative kernel language

Innfører følgende statements:
    skip                                        Empty statement
    <s1> <s2>                                   Statement sequence
    local <x> in <s> end                        Variable creation
    <x1> = <x2>                                 Variable-variable binding
    <x> = <v>                                   Value creationg
    if <x> then <s1> else <s2> end              Conditional
    case <x> of <pat> then <s1> else <s2> end   Pattern matching
    { <x> <y1> ... <yn> }                       Procedure application


# The declarative computation model with exceptions

Innfører følgende statements:
    try <s1> catch <x> then <s2> end            Exception context
    raise <x> end                               Raise exception


Semantikk:
    
    try:
        (try <s1> catch <x> then <s2> end, E)
        - Dytt (catch <x> then <s2> end, E)
        - Dytt (<s1>, E)

    raise:
        (raise <x> end, E)
        - Popp elementer til du finner catch. Hvis du ikke finner, stopp eksekvering med feilmelding: "Uncaught exception"
        - La (catch <y> then <s> end, Ec)
        - Dytt (<s>, Ec + {<y> -> E(<x>)})

    catch:
        (catch <x> then <s> end, E)
        - Popp av stakken

Annet:
    Dersom denne modellen brukes sammen med concurrency, er det fare for at man får en unifikasjonsfeil som IKKE får programmet til å stoppe. Programmet blir derfor ikke-deterministisk, og derfor ikke deklarativt.

# The declarative model with secure types

Innfører følgende statements:
    {NewName <x>}                               Name creation
    <y>=!!<x>                                   Read-only view

# The concurrent data-driven declarative model

Innfører følgende statements:
    thread <s> end                              Thread creation


# The concurrent demand-driven declarative model

Utvider "The concurrent data-driven declarative model" med følgende statements:
    {ByNeed <x> <y>}                            Trigger creation

Utvider eksekveringstilstand:
    Legger til "trigger store" \tau, slik at vi får (MST, \sigma, \tau).

Semantikk
    
    trigger creation:
        ({ByNeed <x> <y>}, E)
        - Hvis E(<y>) er ubestemt, legg til trigger trig(E(<x>), E(<y>)) i \tau.
        - Hvis E(<y>) er bestemt, legg til en ny tråd med initielt statement ({<x> <y>}, E)

    trigger activation:
        Hvis \tau inneholder trig(x, y) og man trenger y, med andre ord det er en tråd som er suspended som venter på at y skal bli bestemt, eller noen som forsøker å binde y, gjør følgende:
        - Fjern triggeren fra \tau.
        - Lag en ny tråd med start-tilstand ({<x> <y>}, {<x> -> x, <y> -> y})


Annet:
    
    {ByNeed P Y} gjør det samme som 'thread {P Y} end', bortsett fra at thread alltid vil kjøre (til slutt), men ByNeed kjører når Y trengs.

    Lat utførelse forutsetter samtidighet, siden den late funksjonen utføres i en egen tråd.


# The message-passing concurrent model
Innfører følgende statements:
    {NewPort <y> <x>}                           Port creation
    {Send <x> <y>}                              Port send

# The declarative model with explicit state
Innfører følgende statements:
    {NewCell <x> <y>}
    {Exchange <x> <y> <z>}
Beholder ikke concurrency.

# The shared-state concurrent model
Beholder elementer fra "The declarative model with explicit state" og "The concurrent data-driven declarative model"

# The relational computation model
Innfører to nye statements:
    chocie - Ikke-deterministisk. Grupperer sammen et sett med alternativer.
    fail - Alternativet er feil. Denne blir kalt implisitt ved unifikasjonsfeil.

#
# DECLARATIVE CONCURRENCY
#

# Lazy execution
Programmeringsparadigme som sier at beregning ikke gjøres før det er nødvendig. Tillater strømmer og rekursive strukturer, gjør det enklere med modularisering og synkronisering.

#
# PARAMETRE
#

En variabel funnet i en funksjonsdefinisjon. Formal parameters refererer til variablene, actual parameters til verdiene.

# Parameter passing

# Call by reference: Prosedyren har tilgang til variablen som aktuelt parameter, man kan binde variablen i prosedyren. Standart i oz.
# Call by variable: Spesialtilfelle av ovenfor. Kopierer referansen og bruker denne som et alias til den aktuelle variablen.
# Call by value: Verdien kopierers, prosedyren kan ikke endre eller binde parameteret.
# Call by value-result: Får en lokal kopi, men overskriver kopien når prosedyren er ferdig. Med andre ord
# Call by name: Det blir sendt inn en thunk til metoden, et funksjonskall som returnerer verdien. Lat utførelse uten memoisering
# Call by need: Thunkene blir lagret én gang. Lat evaluering med memoisering.


#
# ANNET
#

# Statement og expression
Et statement er det samme som en setning. Dette er "a complete unit of execution".
En expression er et oppbygning av variable og funksjonskall som evaluerer til en enkelt verdi.

# SolveOne og SolveAll
SolveOne regner ut den late listen med {Solve $}, og returnerer første resultat (hvis det finnes).
SolveAll regner ut den late listen med {Solve $}, og kjører {TouchAll $} på listen, en funksjon som tvinger alle elementene til å bli generert. Når man kaller SolveAll må man definere en ny funksjon, som dette:
    {SolveAll fun {$} {MyRelativeFunction X Y ... Z} end}

# Closure
En closure er en funksjon sammen med tilhørende miljø. Dette er ulikt en funksjonspeker, som bare peker til funksjonen. En funksjon i en closure har da mulighet til å nå eksterne variable uten å være i nærheten av sit leksikalske skop.

# Bundede og ubundede variable
    I et leksikalsk skop er X bundet i denne setningen:
        local X
            X = 1
        end
    I et leksikalsk skop er X ubundet i denne setningen:
        X = 1
    I et dynamisk skop har vi følgende eksempel:
        1 local X Y in
        2 X = Y
        3 Y = 2
        4 end
    I løpet av kjøretiden her vil X og Y bindes, først til hverandre (delvis bundede), så til tallet 2.

#
# NYTTIGE TING I OZ
# 

# For-løkke
for I in A..B;S do <s> end

#Foreach-løkke
for X in L do <s> end

#
# GRAMATIKKER OG PARSING
#


#
# Gramatikkparsere
#

# Relational boolean grammar parser
\insert 'Solve.oz'

declare
fun {Parse Tokens}
   fun {Expression Before After}
      case After of [X] then
	 % Try to unify Before with nil to see that After is the only element left.
	 Before = nil
	 % Return X, as its the only element left
	 X
      [] H|T then
	 choice
	    % Try to match it with a
	    H = 'a'
	    a({Expression nil Before} {Expression nil T})
	 []
	    % Try to match it with o
	    H = 'o'
	    o({Expression nil Before} {Expression nil T})
	 []
	    % Try to match it with n
	    H = 'n'
	    n({Expression nil T})
	 []
	    % Or we could just try to send it away
	    {Expression {Append Before [H]} T}
	 end
      else
	 % No more elements, obviously not going to lead anywhere.
	 fail
      end
      
   end
in
   {SolveAll fun {$} {Expression nil Tokens} end}
end

fun {Eval ParseTree}
   case ParseTree of a(Exp1 Exp2) then
      {Eval Exp1} andthen {Eval Exp2}
   [] o(Exp1 Exp2) then
      {Eval Exp1} orelse {Eval Exp2}
   [] n(Exp) then
      if {Eval Exp} then false else true end
   [] f then
      false
   [] t then
      true
   end
   
end
%   case ParseTree of a(Exp1 Exp2) then
      

{Browse {Eval o(n(t) o(t f))}}  

#
# ANNEN NYTTIG KODE
#

#Velger ett element fra en liste og returnerer en tuppel med element#resten_av_liste
{PickkOneR L}
   case L of [X] then
      X#nil
   [] H|T then
      choice
     H#T
      [] X#L = {PickOneR T} in
     X#{Append [H] L}
      end
   end    
end
